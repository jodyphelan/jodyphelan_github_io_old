<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>
  <link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css"
            rel="stylesheet">
        <style>

        </style>
        <script src="data.json"></script>
        <script src="d3.v3.min.js"></script>
</head>
<body>

  <input type="number" min="0" max="500" step="5" value="0" id="nValue">


<script>

d3.select("#nValue").on("input", function() {
  svg.remove()
  initData(+this.value);
  initForce();
});


var graph = {};

function initData(SNPs){

//var SNPs=document.getElementById('input1').value;

  console.log(SNPs);
  generateGraphJSON(SNPs);

  function generateGraphJSON(SNPs){
    graph.nodes = data.nodes
    graph.links = data.links.filter(function(dat){
      if(dat.value<SNPs){return dat;}
    });
  }
}

function initForce(){
///////////// Functions Start /////////////

function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

// Resize the window according to the current size. This is called later by an event when the window has changed
function resize() {
	var width = window.innerWidth, height = window.innerHeight;
	svg.attr("width", width).attr("height", height);
  //Changes the force layout too
	force.size([force.size()[0]+(width-w)/zoom.scale(),force.size()[1]+(height-h)/zoom.scale()]).resume();
	w = width;
 	h = height;
 }

// Return the visType
 function vis_by_type(type){
 	switch (type) {
 	  case "circle": return keyc;
 	  case "square": return keys;
 	  case "triangle-up": return keyt;
 	  case "diamond": return keyr;
 	  case "cross": return keyx;
 	  case "triangle-down": return keyd;
 	  default: return true;
 	}
 }

// Return the Node score
 function vis_by_node_score(score){
 	if (isNumber(score)){
 		if (score>=0.666) return keyh;
 		else if (score>=0.333) return keym;
 		else if (score>=0) return keyl;
 	}
 	return true;
 }

// Return the link score
function vis_by_link_score(score){
	if (isNumber(score))	{
		if (score>=0.666) return key3;
		else if (score>=0.333) return key2;
		else if (score>=0) return key1;
	}
	return true;
}

// Function to focus the nodes on clicks
function set_focus(d){
	if (highlight_trans<1)  {
    circle.style("opacity", function(o) {
  		return isConnected(d, o) ? 1 : highlight_trans;
    });
		text.style("opacity", function(o) {
    	return isConnected(d, o) ? 1 : highlight_trans;
    });
    links.style("opacity", function(o) {
      return o.source.index == d.index || o.target.index == d.index ? 1 : highlight_trans;
    });
	}
}

// Function used to highlight the nodes
function set_highlight(d){
	svg.style("cursor","pointer");
	if (focus_node!==null) d = focus_node;
	highlight_node = d;
	if (highlight_color!="white"){
		circle.style(towhite, function(o) {
      return isConnected(d, o) ? highlight_color : "white";
		});
		text.style("font-weight", function(o) {
    	return isConnected(d, o) ? "bold" : "normal";
		});
    links.style("stroke", function(o) {
		      return o.source.index == d.index || o.target.index == d.index ? highlight_color : ((isNumber(o.score) && o.score>=0)?color(o.score):default_link_color);
    });
	}
}

// Function used to exit hte highligthing
function exit_highlight(){
	highlight_node = null;
	if (focus_node===null){
		svg.style("cursor","move");
		if (highlight_color!="white"){
  	  circle.style(towhite, "white");
	  	text.style("font-weight", "normal");
	  	links.style("stroke", function(o) {return (isNumber(o.score) && o.score>=0)?color(o.score):default_link_color});
 		}
	}
}

// Perform actions when keys are pressed
 function keydown() {
   // code 32 == space key
 	if (d3.event.keyCode==32) {  force.stop();}
 	else if (d3.event.keyCode>=48 && d3.event.keyCode<=90 && !d3.event.ctrlKey && !d3.event.altKey && !d3.event.metaKey){
   	switch (String.fromCharCode(d3.event.keyCode)) {
      // "keyc = !keyc" assigns to the inverse of keyc false|true
      case "C": keyc = !keyc; break;
     	case "S": keys = !keys; break;
 			case "T": keyt = !keyt; break;
 			case "R": keyr = !keyr; break;
     	case "X": keyx = !keyx; break;
 			case "D": keyd = !keyd; break;
 			case "L": keyl = !keyl; break;
 			case "M": keym = !keym; break;
 			case "H": keyh = !keyh; break;
 			case "1": key1 = !key1; break;
 			case "2": key2 = !key2; break;
 			case "3": key3 = !key3; break;
 			case "0": key0 = !key0; break;
   	}
 		links.style("display", function(d) {
 			var flag  = vis_by_type(d.source.type)&&vis_by_type(d.target.type)&&vis_by_node_score(d.source.score)&&vis_by_node_score(d.target.score)&&vis_by_link_score(d.score);
 			linkedByIndex[d.source.index + "," + d.target.index] = flag;
       return flag?"inline":"none";
 		});
   	nodes.style("display", function(d) {
 			return (key0||hasConnections(d))&&vis_by_type(d.type)&&vis_by_node_score(d.score)?"inline":"none";
 		});
   	text.style("display", function(d) {
       return (key0||hasConnections(d))&&vis_by_type(d.type)&&vis_by_node_score(d.score)?"inline":"none";
 		});
 		if (highlight_node !== null){
 			if ((key0||hasConnections(highlight_node))&&vis_by_type(highlight_node.type)&&vis_by_node_score(highlight_node.score)) {
 				if (focus_node!==null) set_focus(focus_node);
 				set_highlight(highlight_node);
 			}	else {
 				exit_highlight();
 			}
 		}
 	}
 }

// Finds out if two nodes are connected
 function isConnected(a, b) {
   return linkedByIndex[a.index + "," + b.index] || linkedByIndex[b.index + "," + a.index] || a.index == b.index;
 }

 function hasConnections(a) {
 		for (var property in linkedByIndex) {
 				s = property.split(",");
 				if ((s[0] == a.index || s[1] == a.index) && linkedByIndex[property]) 					return true;
 		}
 	return false;
 	}
//////////// Functions End ///////////////

////////// Definitions Start ////////////
  var w = window.innerWidth;
  var h = window.innerHeight;

  var default_node_color = "#ccc";
  //var default_node_color = "rgb(3,190,100)";
  var default_link_color = "#888";


  var nominal_base_node_size = 8;
  var nominal_text_size = 10;
  var max_text_size = 24;
  var nominal_stroke = 1.5;
  var max_stroke = 4.5;
  var max_base_node_size = 36;
  var min_zoom = 0.1;
  var max_zoom = 7;
  var zoom = d3.behavior.zoom().scaleExtent([min_zoom,max_zoom])

  var text_center = false;
  var outline = false;


  var focus_node = null, highlight_node = null;
//Key Definitions
  var keyc = true, keys = true, keyt = true, keyr = true, keyx = true, keyd = true, keyl = true, keym = true, keyh = true, key1 = true, key2 = true, key3 = true, key0 = true


  var highlight_color = "blue";
  var highlight_trans = 0.1;

  var linkScale = d3.scale.linear()
    .domain([Math.min.apply(Math,data.links.map(function(d){return Number(d.value)})),Math.max.apply(Math,data.links.map(function(d){return Number(d.value)}))])
    .range([0.1,100])

  var size = d3.scale.pow().exponent(1)
    .domain([1,100])
    .range([8,24]);

  zoom.on("zoom", function() {
    var stroke = nominal_stroke;
    if (nominal_stroke*zoom.scale()>max_stroke) stroke = max_stroke/zoom.scale();
    links.style("stroke-width",stroke);
    circle.style("stroke-width",stroke);

  	var base_radius = nominal_base_node_size;
    if (nominal_base_node_size*zoom.scale()>max_base_node_size) base_radius = max_base_node_size/zoom.scale();
    circle.attr("d", d3.svg.symbol()
      .size(function(d) { return Math.PI*Math.pow(size(d.size)*base_radius/nominal_base_node_size||base_radius,2); })
      .type(function(d) { return d.type; }))

  	//circle.attr("r", function(d) { return (size(d.size)*base_radius/nominal_base_node_size||base_radius); })
  	if (!text_center) text.attr("dx", function(d) { return (size(d.size)*base_radius/nominal_base_node_size||base_radius); });

  	var text_size = nominal_text_size;
    if (nominal_text_size*zoom.scale()>max_text_size) text_size = max_text_size/zoom.scale();
    text.style("font-size",text_size + "px");

  	g.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
  });

  var linkedByIndex = {};
  graph.links.forEach(function(d) {
  	linkedByIndex[d.source + "," + d.target] = true;
  });


////////// Definitions End /////////////




  svg = d3.select("body").append("svg");
// Change the style of the cursor when over svg elements
  svg.style("cursor", "move");
  g = svg.append("g");
  svg.call(zoom);


  force = d3.layout.force()
    .size([w,h])
    .linkDistance(60)
    .charge(-300)
    .nodes(graph.nodes)
    .links(graph.links)

  force.linkDistance(function(link) {
    console.log(linkScale(link.value));
    return linkScale(link.value);
  });

  force.start();


  resize();

  links = g.selectAll(".link")
    .data(graph.links).enter()
    .append("line")
    .attr("class","link")
    .style("stroke-width",nominal_stroke)
    .style("stroke", function(d) {
	    if (isNumber(d.score) && d.score>=0) return color(d.score);
	    else return default_link_color;
    })

  nodes = g.selectAll(".node")
    .data(graph.nodes).enter()
    .append("g")
    .attr("class","node")
    .call(force.drag)

  var tocolor = "fill";
  var towhite = "stroke";
  if (outline) {
  	tocolor = "stroke"
  	towhite = "fill"
  }


  circle = nodes.append("path")
    .attr("d", d3.svg.symbol()
      .size(function(d) { return Math.PI*Math.pow(size(d.size)||nominal_base_node_size,2); })
      .type(function(d) { return d.type; })
    )
    .style(tocolor,function (d){
      if (isNumber(d.score) && d.score>=0) return color(d.score);
      else return default_node_color;
    })
    .style("stroke-width", nominal_stroke)
    .style(towhite, "white")


  var text = g.selectAll(".text")
    .data(graph.nodes)
    .enter().append("text")
    .attr("dy", ".35em")
    .style("font-size", nominal_text_size + "px")

  if (text_center){
    text.text(function(d) { return d.id; })
      .style("text-anchor", "middle");
  } else {
    text.attr("dx", function(d) {return (size(d.size)||nominal_base_node_size);})
      .text(function(d) { return '\u2002'+d.id; });
  }

// Highlights the nodes when the mouse hovers over
  nodes.on("mouseover", function(d) {
    set_highlight(d);
  })
// Highlights all the connecting nodes on mouse click on node
    .on("mousedown", function(d) { d3.event.stopPropagation();
        focus_node = d;
        set_focus(d)
        if (highlight_node === null) set_highlight(d)
    }).on("mouseout", function(d) {
    		exit_highlight();
    });


// This makes the nodes stop highlighting when the mouse click is released
  d3.select(window).on("mouseup",function() {
    if (focus_node!==null){
    	focus_node = null;
    	if (highlight_trans<1){
    		circle.style("opacity", 1);
    	  text.style("opacity", 1);
    	  links.style("opacity", 1);
    	}
    }
    if (highlight_node === null) exit_highlight();
  });


// This makes the viz resize when the window size changes - calls to function resize
  d3.select(window).on("resize", resize).on("keydown", keydown);

// This actually starts the force simulation and tracks the coordinate changes
  force.on("tick",function(){
    nodes
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
    text
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

    links
      .attr("x1",function(d){return d.source.x})
      .attr("x2",function(d){return d.target.x})
      .attr("y1",function(d){return d.source.y})
      .attr("y2",function(d){return d.target.y});

    nodes
    .attr("cx", function(d) { return d.x; })
    .attr("cy", function(d) { return d.y; });
  });

}

initData(0);
initForce();








  </script>


  </body>
  </html>
